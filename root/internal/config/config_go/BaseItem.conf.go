package config_go

// Code generated by excelExoprt. DO NOT EDIT.
// source: BaseItem.xlsx

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path"
)

// array and map
var _BaseItemMap = map[int64]*BaseItem{}
var _BaseItemArray = []*BaseItem{}

type BaseItem struct {
	data *_BaseItem
}

// 类型结构
type _BaseItem struct {
	INT_ID           int64  // 物品ID
	STR_NAME         string // 道具名称本地化
	INT_TYPE         int64  // 物品子类型
	STR_ICON_URL     string // 图标
	INT_SORT_INDEX   int64  // 排序
	INT_MAX_OVER_LAY int64  // 堆叠数量
	INT_QUALITY      int64  // 物品品质
	INT_CAN_SELL     int64  // 是否可以出售
	INT_SELL_PRICE   int64  // 卖出价格
	INT_DROP_SORT_ID int64  // 系统掉落排序
	INT_REWARD_POOL  int64  // 礼包内容reward_pool_id
	INT_BUILDING     int64  // 对应建筑Id
}

func (c *BaseItem) ID() int64           { return c.data.INT_ID }           //物品ID
func (c *BaseItem) NAME() string        { return c.data.STR_NAME }         //道具名称本地化
func (c *BaseItem) TYPE() int64         { return c.data.INT_TYPE }         //物品子类型
func (c *BaseItem) ICON_URL() string    { return c.data.STR_ICON_URL }     //图标
func (c *BaseItem) SORT_INDEX() int64   { return c.data.INT_SORT_INDEX }   //排序
func (c *BaseItem) MAX_OVER_LAY() int64 { return c.data.INT_MAX_OVER_LAY } //堆叠数量
func (c *BaseItem) QUALITY() int64      { return c.data.INT_QUALITY }      //物品品质
func (c *BaseItem) CAN_SELL() int64     { return c.data.INT_CAN_SELL }     //是否可以出售
func (c *BaseItem) SELL_PRICE() int64   { return c.data.INT_SELL_PRICE }   //卖出价格
func (c *BaseItem) DROP_SORT_ID() int64 { return c.data.INT_DROP_SORT_ID } //系统掉落排序
func (c *BaseItem) REWARD_POOL() int64  { return c.data.INT_REWARD_POOL }  //礼包内容reward_pool_id
func (c *BaseItem) BUILDING() int64     { return c.data.INT_BUILDING }     //对应建筑Id

func HasBaseItem(key int64) bool {
	_, ok := _BaseItemMap[key]
	return ok
}

func GetBaseItem(key int64) *BaseItem {
	return _BaseItemMap[key]
}

func RangeBaseItem(fn func(i int, row *BaseItem) (stop bool)) {
	for i, row := range _BaseItemArray {
		if fn(i, row) {
			break
		}
	}
}

func LenBaseItem() int { return len(_BaseItemArray) }

func init() {
	loadfn["BaseItem"] = loadBaseItem
}

func loadBaseItem(dir string) error {
	data, err := ioutil.ReadFile(path.Join(dir, "BaseItem.json"))
	if err != nil {
		return fmt.Errorf("file=%v read err=%v", err.Error())
	}

	datas := []*_BaseItem{}
	err = json.Unmarshal(data, &datas)
	if err != nil {
		return fmt.Errorf("file=%v parse err=%v", err.Error())
	}

	result_array := []*BaseItem{}
	result_map := map[int64]*BaseItem{}
	for _, row := range datas {
		data := &BaseItem{data: row}
		result_array = append(result_array, data)
		result_map[row.INT_ID] = data
	}
	_BaseItemArray = result_array
	_BaseItemMap = result_map
	fmt.Printf("%-50v len:%v\n", "BaseItem load finish! ", len(result_array))
	return nil
}
