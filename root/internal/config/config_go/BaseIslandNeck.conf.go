package config_go

// Code generated by excelExoprt. DO NOT EDIT.
// source: BaseIslandNeck.xlsx

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path"
)

// array and map
var _BaseIslandNeckMap = map[int64]*BaseIslandNeck{}
var _BaseIslandNeckArray = []*BaseIslandNeck{}

type BaseIslandNeck struct {
	data *_BaseIslandNeck
}

// 类型结构
type _BaseIslandNeck struct {
	INT_ID               int64     // ID
	INT_ISLAND_ID        int64     // 归属岛屿
	INT_TYPE             int64     // 类型
	ARRAYSTR_POSITION    array_str // 坐标
	INT_PVE_STAGE_UNLOCK int64     // 解锁关卡
	STR_ICON_URL         string    // 卡槽Icon
}

func (c *BaseIslandNeck) ID() int64        { return c.data.INT_ID }        //ID
func (c *BaseIslandNeck) ISLAND_ID() int64 { return c.data.INT_ISLAND_ID } //归属岛屿
func (c *BaseIslandNeck) TYPE() int64      { return c.data.INT_TYPE }      //类型
//坐标
func (c *BaseIslandNeck) Len_POSITION() int           { return c.data.ARRAYSTR_POSITION.Len() }
func (c *BaseIslandNeck) Get_POSITION(key int) string { return c.data.ARRAYSTR_POSITION.Get(key) }
func (c *BaseIslandNeck) Range_POSITION(fn func(int, string) (stop bool)) {
	c.data.ARRAYSTR_POSITION.Range(fn)
}
func (c *BaseIslandNeck) Copy_POSITION() array_str { return c.data.ARRAYSTR_POSITION.Copy() }
func (c *BaseIslandNeck) PVE_STAGE_UNLOCK() int64  { return c.data.INT_PVE_STAGE_UNLOCK } //解锁关卡
func (c *BaseIslandNeck) ICON_URL() string         { return c.data.STR_ICON_URL }         //卡槽Icon

func HasBaseIslandNeck(key int64) bool {
	_, ok := _BaseIslandNeckMap[key]
	return ok
}

func GetBaseIslandNeck(key int64) *BaseIslandNeck {
	return _BaseIslandNeckMap[key]
}

func RangeBaseIslandNeck(fn func(i int, row *BaseIslandNeck) (stop bool)) {
	for i, row := range _BaseIslandNeckArray {
		if fn(i, row) {
			break
		}
	}
}

func LenBaseIslandNeck() int { return len(_BaseIslandNeckArray) }

func init() {
	loadfn["BaseIslandNeck"] = loadBaseIslandNeck
}

func loadBaseIslandNeck(dir string) error {
	data, err := ioutil.ReadFile(path.Join(dir, "BaseIslandNeck.json"))
	if err != nil {
		return fmt.Errorf("file=%v read err=%v", err.Error())
	}

	datas := []*_BaseIslandNeck{}
	err = json.Unmarshal(data, &datas)
	if err != nil {
		return fmt.Errorf("file=%v parse err=%v", err.Error())
	}

	result_array := []*BaseIslandNeck{}
	result_map := map[int64]*BaseIslandNeck{}
	for _, row := range datas {
		data := &BaseIslandNeck{data: row}
		result_array = append(result_array, data)
		result_map[row.INT_ID] = data
	}
	_BaseIslandNeckArray = result_array
	_BaseIslandNeckMap = result_map
	fmt.Printf("%-50v len:%v\n", "BaseIslandNeck load finish! ", len(result_array))
	return nil
}
